# Analysis Scripts

These scripts are used to create the Gnina run files and analyze the outputs of Gnina.

### make\_gnina\_cmds.py
Generates a file that will run the specified Gnina parameter sweeps. Requires a space-delimited file that lists receptor, ligand, autobox\_ligand, and the prefix of the Gnina output file.

### obrms\_calc.py
Calculates the RMSD from the poses in the Gnina output files to the known ligand binding pose using OpenBabel's *obrms* tool. Requires the Gnina command file generated by **make\_gnina\_cmds.py**

### coalescer.py
Creates a master csv containing rmsd information and scores output by Gnina.

## Running the full analysis pipeline

In order to get the same results as shown in the paper, you must run a series of sweeps of the parameters within Gnina using the above mentioned scripts.
1. First you must download all of the data for both the redocking and crossdocking into this directory, these can be found at https://bits.csb.pitt.edu/files/gnina1.0_paper/. Then extract both the *crossdocked_ds_data.tar.gz* and *redocking\_all\_data.tar.gz* files into this directory using: `tar xzf <filename>`.

1. Now we must create the run files for Gnina. This step requires a space-delimited file containing the receptor, ligand, autobox\_ligand, and the prefix of the output file (These are provided as *rd\_input\_pairs.txt*, *rd\_wp\_input\_pairs.txt*, *ds\_cd\_input\_pairs.txt*, and *ds\_cd\_wp\_input\_pairs.txt*, where *ds\_cd* indicates downsampled cross-docking, *rd* indicates redocking, and *wp* indicates whole protein). This is used as input to the *make\_gnina\_cmds.py* script along with an output file name, the CNNs to use, the cnn\_scoring method, and any arguments for the parameters.

    Example: `python make_gnina_cmds.py --input rd_input_pairs.txt --output redock_exhaustiveness_sweep.txt --cnn dense general_default2018_3 dense_3 crossdock_default2018 redock_default2018 --exhaustiveness 4 8 16`
    
    This will create a file *redock\_exhaustiveness\_sweep.txt* containing Gnina run commands for each protein-ligand pair in the input file *rd\_input\_pairs.txt* for each of the exhaustiveness arguments specified. By default the script will use seed=420 and cnn\_scoring=rescore unless specified otherwise.

    The tables below show all of the different arguments to provide *make\_gnina\_cmds.py* in order to run all of the sweeps shown in the paper:

    ### Model comparisons

	Model | \-\-cnn | \-\-cnn\_scoring 
	----- | ------- | ----------------
	crossdock\_default2018 single model | crossdock\_default2018 | rescore 
	dense | dense | rescore 
	default2017 | default2017 | rescore 
	general\_default2018 single model | general\_default2018 | rescore 
	redock\_default2018 single model | redock\_default2018 | rescore 
	crossdock\_default2018 ensemble | crossdock\_default2018\_ensemble | rescore 
	dense ensemble | dense\_ensemble | rescore 
	general\_default2018 ensemble | general\_default2018\_ensemble | rescore 
	redock\_default2018 ensemble | redock\_default2018\_ensemble | rescore 
	All Ensemble | \_ensemble | rescore 
	Default Ensemble Rescore |  **NA** | rescore 
	Vina | **NA** | none |
	Default Ensemble Refinement | **NA** | refinement 


    ### Defined pocket Sweeps
    Each of these should use the Default Ensemble (i.e. no argument provided for `--cnn`) with rescoring enabled 

    | Sweep Argument | Values |
    |------|-----|
    | --exhaustiveness | 4,8,16<sup>*</sup> | 
    | --num\_mc\_saved | 20,40,50,60,80,100 | 
    | --num\_modes | 9,100 |
    | --autobox\_add | 2,4,6,8 |
    | --min\_rmsd\_filter | 0.5,1.0,1.5 |
    | --cnn\_rotation | 0,1,5,10,20 |

    *The exhaustiveness sweep also requires the same sweep specified using `--cnn_scoring none` so you can get both Vina and Default Ensemble results

    ### Whole Protein Sweeps
    Each of these should use the Default Ensemble (i.e. no argument provided for `--cnn`). These should use the files with *wp* in the name for the input, i.e. *ds\_cd\_wp\_input\_pairs.txt* and *rd\_wp\_input\_pairs.txt*.
    
    |\-\-cnn\_scoring |Sweep Argument | values |
    | --------------- | ------------- | ------ |
    | rescore | --exhaustiveness | 8,16,32,64 |
    | none | --exhaustiveness | 8,16,32,64 |


2. The output will be used to run Gnina and get a set of output poses and scores from Gnina. This can be accomplished by using a simple bash script which pulls out and runs lines one at a time from the file output by *make\_gnina\_cmds.py*.
	```bash
	    while IFS="" read -r p || [ -n "$p" ]
	    do
		echo $p 

		eval $p   

	    done < MAKE_GNINA_CMDS_OUTPUT.TXT

	```
   
	This will run each line in the *MAKE\_GNINA\_CMDS\_OUTPUT.TXT*. Following the previous example, *MAKE\_GNINA\_CMDS\_OUTPUT.TXT*=*redock\_exhaustiveness\_sweep.txt*.

3. After all of the Gnina runs have completed, you need to next run the RMSD calculation using *obrms\_calc.py*. This will create a *rmsds* file from each *sdf.gz* output of the Gnina runs in the last step. 

	Example: `python obrms_calc.py --input rd_input_pairs.txt --dirname PDBbind_refined_2019/ --getscores` 
	
	The *input* argument will be the same value as what you used as in the *make\_gnina\_cmds.py* *input* argument. The argument to *dirname* will change depending on if you are using the redocking data (*PDBbind\_refined\_2019/*) or the crossdocking data (*carlos\_cd/*).
	
	Note: only use  *--getscores* if the Gnina runs had *--cnn_scoring*=*rescore*, *refinement*, or *all*.

4. Combine the RMSD and score information into one file for each sweep. This requires the *coalescer.py* script, for each sweep you will need to identify the suffix of the run outputs that will allow you to easily group the files, you also need a set of values such that all of the files that you are coalescing into one csv are named _*\<SUFFIX\>\<VALUE\>.rmsds_.
    
    Example: `python coalescer.py --dirlist rd_dirs.txt --suffix autoblig_default_ensemble_rescore_exhaustiveness --values 4 8 16 --dataroot PDBbind_refined_2019 --outfilename final_redock_exhaustiveness_sweep.csv --getscores`
    
    This example will group all files with names _\*autoblig_default_ensemble_rescore_exhaustiveness4.rmsds_, _\*autoblig_default_ensemble_rescore_exhaustiveness8.rmsd_, and _\*autoblig_default_ensemble_rescore_exhaustiveness16.rmsd_.
    
    The *dirlist* options are provided as *rd\_dirs.txt* and *ds\_cd\_dirs.txt* for redocking and cross-docking, respectively. The *dataroot* is the same value that was passed to *dirname* when using *obrms\_calc.py*.

5. Now that the RMSD and CNN scores have been combined, you can now alter the *MakeCrossDockCSVs.ipynb* or *MakeReDockCSVs.ipynb* with the name and location of your files to produce the input needed to make the figures. These notebooks utilize the csvs made by *coalescer.py* to make a TopN csv to use for plotting TopN as a function of N.

6. The graphs can be made by using the *MakeFinalGraphs.ipynb* this will take in the TopN csvs and create the same graphics shown in the paper.


## Pipeline for Flexible Docking

1. Download the crossdocking dataset from [https://bits.csb.pitt.edu/files/gnina1.0_paper/](https://bits.csb.pitt.edu/files/gnina1.0_paper/) and extract `crossdocked_ds_data.tar.gz` using `tar -xzf crossdocked_ds_data.tar.gz`.

2. The `ds_cd_input_pairs.txt` file contains the receptor, ligand, `autobox_ligand`, and the prefix of the output file. `autobox_ligand` is used also as argument of `flexdist_ligand`. The information in such file can be used to run `gnina` as follows (where the variable `LINE` runs over line indices):

```bash
isystems=$(sed -n "${LINE}p" ds_cd_input_pairs.txt)

receptor=$(echo ${isystems} | cut -f1 -d " ")
ligand=$(echo ${isystems} | cut -f2 -d " ")
boxlig=$(echo ${isystems} | cut -f3 -d " ")
prefix=$(echo ${isystems} | cut -f4 -d " ")

gnina -r ${receptor} -l ${ligand} \
    --flexdist_ligand ${boxlig} --flexdist 3.5 \
    --autobox_ligand ${boxlig} \
    --num_modes 10 --seed 42 \
    --out ${prefix}fd.sdf --out_flex ${prefix}fd-RES.pdb
```

3. In order to use `obrms_calc.py` and `coalescer.py` for analysis, the file generated by `make_gnina_cmds.py` is needed. However, for flexible docking we did not use `make_gnina_cmds.py` to create the `gnina` command and we used the one described at point 2. Therefore, we have to create the `gnina` commands file manually and it needs to contain the minimal information needed by `obrms_calc.py` to compute the RMSD (namely, input and output ligands):

```bash
isystems=$(sed -n "${LINE}p" ds_cd_input_pairs.txt)

receptor=$(echo ${isystems} | cut -f1 -d " ")
ligand=$(echo ${isystems} | cut -f2 -d " ")
prefix=$(echo ${isystems} | cut -f4 -d " ")

echo "gnina -l ${ligand} --out ${prefix}fd.sdf" >> gnina_lig-ligout_fd.txt
```

4. Run `obrms_calc.py` (using using `gnina_lig-ligout_fd.txt` as `--input` parameter) and `coalescer.py`, as described above in order to compute the ligand RMSD for all docked poses. This will result in a file like [cd-carlos-CNNrescore-e8-d3.5-LIG.csv](../data/crossdocking-flex/cd-carlos-CNNrescore-e8-d3.5-LIG.csv)

5. Run `pocketdiff.py` to obtain the difference between the cognate receptor and the target receptor. This will result in the file [pocketdiff.csv](../data/crossdocking-flex/pocketdiff.csv)

6. With the files generated at points 4 and 5 (that can be found in [data/crossdocking-flex](../data/crossdocking-flex)) and the RMSD file obtained for standard docking (as described above, also available in [data/crossdocking-flex](../data/crossdocking-flex)), graphs can be generated with the [MakeFlexGraphs.ipynb](MakeFlexGraphs.ipynb) Jupyter Notebook.
